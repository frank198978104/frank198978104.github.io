---
layout: post
title:  "JavaScript 作用域和作用域鏈"
date:   2015-05-20 14:06:05
categories: JavaScript
tags: JavaScript 作用域 慕課網 ife
excerpt: JavaScript 作用域和作用域鏈學習筆記。
---

* content
{:toc}

## JavaScript 作用域

作用域就是變量與函數的可訪問範圍。在JavaScript中，變量的作用域有全局作用域和局部作用域兩種。

---

### 全局作用域(Global Scope)

在代碼中任何地方都能訪問到的對象擁有全局作用域，一般來說以下 3 種情形擁有全局作用域。

1. 最外層函數和在最外層函數外面定義的變量擁有全局作用域

```js
var outVariable = "我是最外層變量"; //最外層變量
function outFun() { //最外層函數
    var inVariable = "內層變量";
    function innerFun() { //內層函數
        console.log(inVariable);
    }
    innerFun();
}
console.log(outVariable); //我是最外層變量
outFun(); //內層變量
console.log(inVariable); //inVariable is not defined
innerFun(); //innerFun is not defined
```

2. 所有末定義直接賦值的變量自動聲明為擁有全局作用域

```js
function outFun2() {
    variable = "未定義直接賦值的變量";
    var inVariable2 = "內層變量2";
}
outFun2();//要先執行這個函數，否則根本不知道裡面是啥
console.log(variable); //未定義直接賦值的變量
console.log(inVariable2); //inVariable2 is not defined
```

3. 所有window對象的屬性擁有全局作用域   
    window對象的內置屬性都擁有全局作用域，例如 `window.name`、`window.location`、`window.top` 等。

### 局部作用域(Local Scope)

和全局作用域相反，局部作用域一般只在固定的代碼片段內可訪問到，最常見的例如函數內部，所有在一些地方也會看到有人把這種作用域稱為函數作用域
。

如 1. 中的變量 `inVariable` 和函數 `innerFun` 都只擁有局部作用域。

---

### 再補充幾個例子

* 全局作用域，函數作用域，eval作用域

```js
var a = 10; // 全局

(function() {
    var b = 20;// 函數
})();
console.log(a); // 10
console.log(b); // error, b in not defined

eval("var a = 1;"); // eval
```

* JavaScript 中沒有塊作用域

```js
for (var item in {
    a: 1,
    b: 2
}) {
    console.log(item);
}
console.log(item); // item still in scope
```

---

## 作用域鏈(Scope Chain)

在 JavaScript 中，函數也是對象，實際上，JavaScript 裡一切都是對象。函數對象和其它對象一樣，擁有可以通過代碼訪問的屬性和一系列僅供 JavaScript 引擎訪問的內部屬性。其中一個內部屬性是 [[Scope]]，由 ECMA-262 標準第三版定義，該內部屬性包含了函數被創建的作用域中對象的集合，這個集合被稱為函數的作用域鏈，它決定了哪些數據能被函數訪問。

1. 在函數創建時，它的作用域鏈中會填入一個全局對象，該全局對象包含了所有全局變量。
2. 函數執行時會創建一個稱為“運行期上下文(execution context)”的內部對象，運行期上下文定義了函數執行時的環境。每個運行期上下文都有自己的作用域鏈，用於標識符解析，當運行期上下文被創建時，而它的作用域鏈初始化為當前運行函數的[[Scope]]所包含的對象。
3. 這些值按照它們出現在函數中的順序被複製到運行期上下文的作用域鏈中。它們共同組成了一個新的對象，叫“活動對象(activation object)”，該對象包含了函數的所有局部變量、命名參數、參數集合以及this，然後此對象會被推入作用域鏈的前端。
4. 當運行期上下文被銷毀，活動對象也隨之銷毀。

在函數執行過程中，每遇到一個變量，都會經歷一次標識符解析過程以決定從哪裡獲取和存儲數據。該過程從作用域鏈頭部，也就是從活動對象開始搜索，查找同名的標識符，如果找到了就使用這個標識符對應的變量，如果沒找到繼續搜索作用域鏈中的下一個對象，如果搜索完所有對象都未找到，則認為該標識符未定義。函數執行過程中，每個標識符都要經歷這樣的搜索過程。

---

### 例子

舉一個作用域鏈的例子。

```js
var outVariable = "我是最外層變量"; //最外層變量
function outFun() { //最外層函數
    var inVariable = "內層變量";
    function innerFun() { //內層函數
        console.log(inVariable);
        var tempVariable = inVariable;
    }
    innerFun();
}
```

對最開始的代碼稍加修改

其作用域鏈為：

```
window
├──outVariable
└──outFun()
   ├──inVariable
   └──innerFun()
      └──tempVariable
```

對於 `innerFun()`，其作用域鏈包含 3 個對象：innerFun() 自己的變量對象、outFun()的變量對象、全局變量對象。

---

#### 特例-構造器創建的函數

```js
function outer() {
    var i = 1;
    var func = new Function("console.log(typeof i);");
    func(); // undefined
}
outer();
```

通過構造器創建的函數是訪問不到外層的局部變量的。

---

### 延長作用域鏈

有些語句可以在作用域鏈的前端臨時增加一個變量對象，該變量對象會在代碼執行後被移除。有兩種情況下會發生這種現象。

* `try-catch` 語句中的 `catch` 塊
* `with` 語句

對 with 來說，將會指定對象添加到作用域鏈中。對 catch 來說，會創建一個新的變量對象，其中包含的是被拋出的錯誤對象的聲明。

---

### 代碼優化

從作用域鏈的結構可以看出，在運行期上下文的作用域鏈中，標識符所在的位置越深，讀寫速度就會越慢。因為全局變量總是存在於運行期上下文作用域鏈的最末端，因此在標識符解析的時候，查找全局變量是最慢的。所以，在編寫代碼的時候應盡量少使用全局變量，盡可能使用局部變量。一個好的經驗法則是：如果一個跨作用域的對象被引用了一次以上，則先把它存儲到局部變量裡再使用。

---

## VO & AO

### 變量初始化階段

* JS解釋器如何找到我們定義的函數和變量？

    變量對象 (Variable Object, 縮寫為VO) 是一個抽象概念中的“對象”，它用於存儲執行上下文中的：

    1. 變量
    2. 函數聲明
    3. 函數參數

* VO按照如下順序填充:

    1. 函數參數 (若未傳入，初始化該參數值為undefined)    
    2. 函數聲明 (若發生命名衝突，會覆蓋)   
    3. 變量聲明 (初始化變量值為 undefined，若發生命名衝突，會忽略。)

```js
function foo(x, y, z) {
    function x() {};
    console.log(x);
}
foo(100); // funtion x()

function foo2(x, y, z) {
    var x = 50;
    console.log(x);
}
foo2(110); // 50

function foo3() {
    function x() {};
    var x = 100;
    console.log(x);
}
foo3(); // 100

function foo4() {
    function x() {};
    var x;
    console.log(x);
}
foo4(); // funtion x()
```

**注：函數表達式不會影響 VO**

---

### 代碼執行階段

給 VO 對象內的變量賦值。

VO 變為 AO （活動對象 activation object）。

---

### 例

```js
alert(x); // function

var x = 10;
alert(x); // 10
x = 20;

function x() {}
alert(x); // 20

if (true) {
    var a = 1;
} else {
    var b = true;
}

alert(a); // 1
alert(b); // undefined
```

---

## 參考資料

* [鳥哥：Javascript作用域原理](http://www.laruence.com/2009/05/28/863.html)
* [理解 JavaScript 作用域和作用域鏈](http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html)
* [JavaScript 深入淺出-慕課網](http://www.imooc.com/learn/277)
